"""
Version 1.7 of Owen Chin Bot â€“ City Priority + Completion-Aware Meeples
"""

from helper.game import Game
from lib.interact.tile import Tile
from lib.interface.events.moves.move_place_tile import MovePlaceTile
from lib.interface.events.moves.move_place_meeple import (
    MovePlaceMeeple,
    MovePlaceMeeplePass,
)
from lib.interface.queries.typing import QueryType
from lib.interface.queries.query_place_tile import QueryPlaceTile
from lib.interface.queries.query_place_meeple import QueryPlaceMeeple
from lib.interface.events.moves.typing import MoveType
from lib.config.map_config import MAX_MAP_LENGTH, MONASTARY_IDENTIFIER
from lib.interact.structure import StructureType


class BotState:
    def __init__(self):
        self.last_tile: Tile | None = None
        self.meeples_placed: int = 0


def main():
    game = Game()
    bot_state = BotState()

    while True:
        query = game.get_next_query()
        def choose_move(query: QueryType) -> MoveType:
            match query:
                case QueryPlaceTile() as q:
                    return handle_place_tile(game, bot_state, q)
                case QueryPlaceMeeple() as q:
                    return handle_place_meeple(game, bot_state, q)
                case _:
                    assert False, "Unhandled query type"
        game.send_move(choose_move(query))


def handle_place_tile(
    game: Game,
    bot_state: BotState,
    query: QueryPlaceTile
) -> MovePlaceTile:
    grid = game.state.map._grid
    MAX = MAX_MAP_LENGTH
    directions = [(1,0), (0,1), (-1,0), (0,-1)]

    # Collect all empty neighbour spots
    spots = []
    seen = set()
    for placed in game.state.map.placed_tiles:
        px, py = placed.placed_pos
        for dx, dy in directions:
            nx, ny = px+dx, py+dy
            if 0 <= nx < MAX and 0 <= ny < MAX and grid[ny][nx] is None and (nx,ny) not in seen:
                seen.add((nx,ny))
                spots.append((nx,ny))

    best_score = -1
    best_move = None

    for nx, ny in spots:
        for ti, tile in enumerate(game.state.my_tiles):
            for _ in range(4):
                if not game.can_place_tile_at(tile, nx, ny):
                    tile.rotate_clockwise(1)
                    continue

                score = 0
                for edge, st in tile.internal_edges.items():
                    if st == StructureType.CITY:
                        score += 2  # base score for city edge
                        dx, dy = {
                            "top_edge": (0, -1),
                            "right_edge": (1, 0),
                            "bottom_edge": (0, 1),
                            "left_edge": (-1, 0),
                        }[edge]
                        ax, ay = nx + dx, ny + dy
                        if 0 <= ax < MAX and 0 <= ay < MAX:
                            adj = grid[ay][ax]
                            if adj:
                                adj_edge = {
                                    "top_edge": "bottom_edge",
                                    "right_edge": "left_edge",
                                    "bottom_edge": "top_edge",
                                    "left_edge": "right_edge",
                                }[edge]
                                if adj.internal_edges[adj_edge] == StructureType.CITY:
                                    score += 3  # reward for continuing city

                if score > best_score:
                    best_score = score
                    best_move = (tile.copy(), nx, ny, ti)
                tile.rotate_clockwise(1)

    if best_move:
        tile, nx, ny, ti = best_move
        tile.placed_pos = (nx, ny)
        bot_state.last_tile = tile
        return game.move_place_tile(query, tile._to_model(), ti)

    raise RuntimeError("No valid tile placement found")


def handle_place_meeple(
    game: Game,
    bot_state: BotState,
    query: QueryPlaceMeeple
) -> MovePlaceMeeplePass | MovePlaceMeeple:
    recent = bot_state.last_tile
    if not recent or game.state.me.num_meeples == 0:
        return game.move_place_meeple_pass(query)

    placeable = game.state.get_placeable_structures(recent._to_model())

    def completed(edge: str) -> bool:
        return game.state._check_completed_component(recent, edge)

    def open_connections(tile: Tile, target_edge: str) -> int:
        count = 0
        for edge, st in tile.internal_edges.items():
            if st == tile.internal_edges.get(target_edge):
                if not completed(edge):
                    count += 1
        return count

    # 1. City, if uncompleted and low number of open ends
    for edge, st in placeable.items():
        if st == StructureType.CITY and not completed(edge):
            if open_connections(recent, edge) <= 3:
                return game.move_place_meeple(query, recent._to_model(), edge)

    # 2. Road, same condition
    for edge, st in placeable.items():
        if st in (StructureType.ROAD, StructureType.ROAD_START) and not completed(edge):
            if open_connections(recent, edge) <= 2:
                return game.move_place_meeple(query, recent._to_model(), edge)

    # 3. Monastery
    if MONASTARY_IDENTIFIER in placeable and not completed(MONASTARY_IDENTIFIER):
        return game.move_place_meeple(query, recent._to_model(), MONASTARY_IDENTIFIER)

    # 4. Late game farming
    if len(game.state.map.available_tiles) <= 10:
        for edge, st in placeable.items():
            if st == StructureType.FIELD:
                return game.move_place_meeple(query, recent._to_model(), edge)

    return game.move_place_meeple_pass(query)


if __name__ == "__main__":
    main()
